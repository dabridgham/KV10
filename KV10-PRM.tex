\documentclass[12pt]{report}
%Gummi|065|=)
\pagestyle{headings}

%\usepackage{fullpage}
%\usepackage{calc}
\usepackage{graphicx}
\usepackage[hidelinks=true]{hyperref}

\newcommand{\code}[1]{\textsf{#1}}

\newenvironment{register36}
  { \noindent
    \setlength{\dimen0}{0.0272\textwidth}
    \setlength{\unitlength}{\dimen0}
    \begin{picture}(36, 3)
      % make the box outline
      \put(0, 2){\line(1, 0){36}}
      \put(0, 0){\line(1, 0){36}}
      \put(0,0){\line(0,1){2}}
      \put(36,0){\line(0,1){2}}
      % put the numbers on top
      \count255 = 0
      \loop
        \put(\the\count255, 2.3){\makebox[\dimen0][c]
	  {\tiny\number\count255}}
	\ifnum\count255 < 35
	\advance\count255 by 1
	\repeat

      \newcommand{\bit}[2] {
	\put(##1,0){\line(0,1){2}}
	\put(##1,0)
	    {\parbox[b][2\dimen0][c]{\dimen0}
	      {\begin{center} \tiny ##2 \end{center}}}
	    \count255 = ##1
	    \advance\count255 by 1
	    \put(\the\count255,0){\line(0,1){2}}  
      }
      	
    \newcommand{\bits}[3] {
      \put(##1,0){\line(0,1){2}}
      \count255 = ##2
      \advance\count255 by 1
      \put(\the\count255,0){\line(0,1){2}}
      \advance\count255 by -##1 % get the width of the field
      \put(##1,0)
	  {\parbox[b][2\dimen0][c]{\the\count255\dimen0}
	    {\centering \tiny ##3 }}
    }
  }
  {\end{picture} \smallskip}
	 

\begin{document}
\title{KV10 Processor Reference Manual}
\author{David Bridgham \\ \textless dab@froghouse.org\textgreater}

\maketitle

\begin{abstract}
This document describes the KV10 processor by describing how it differs from Dave Conroy's
PDP-10/X.
\end{abstract}

\tableofcontents

\chapter{Introduction}
The KV10 is an implementation of the Digital Equipment Corporation's PDP-10 architecture,
written in Verilog, and realized (thus far) on an FPGA. It mostly follows the PDP-10/X
architecture, designed by Dave Conroy and described in his \textit{PDP-10/X System
  Manual}\cite{conroykx10}, and, like Dave's design, is initially targeted at supporting
the Incompatible Timesharing System (ITS) from MIT.

For now, this document is woefully incomplete.  It contains a mix of things I've done,
things I plan to do, and flights of fancy about where this project could go one day.  It
is slowly growing to describe more and more of the processor and may one day even
delineate those three categories.  For now, determining what's real and what's speculative
is left as an exercise to the reader.

\begin{figure}
\begin{register36}
\bits{0}{8}{\small Opcode}
\bits{9}{12}{\small AC}
\bit{13}{\small I}
\bits{14}{17}{\small Index}
\bits{18}{35}{\small Y}
\end{register36}

\begin{register36}
\bits{0}{2}{\small 7}
\bits{3}{9}{\small Device}
\bits{10}{12}{\small Op}
\bit{13}{\small I}
\bits{14}{17}{\small Index}
\bits{18}{35}{\small Y}
\end{register36}
\caption{Normal and I/O Instruction Formats}
\end{figure}

\section{Internal Modules}

\begin{figure}
\setlength{\unitlength}{.01\textwidth}
\begin{picture}(95,28)
  \thicklines
  
  \put(0,11){\line(1,0){20}}
  \put(0,17){\line(1,0){20}}
  \put(0,11){\line(0,1){6}}
  \put(20,11){\line(0,1){6}}
  \put(7,13){\code APR}

  \put(0,22){\line(1,0){20}}
  \put(0,28){\line(1,0){20}}
  \put(0,22){\line(0,1){6}}
  \put(20,22){\line(0,1){6}}
  \put(5,24){\code Console}
  
  \put(25,11){\line(1,0){20}}
  \put(25,17){\line(1,0){20}}
  \put(25,11){\line(0,1){6}}
  \put(45,11){\line(0,1){6}}
  \put(32,13){\code PAG}
  
  \put(50,11){\line(1,0){20}}
  \put(50,17){\line(1,0){20}}
  \put(50,11){\line(0,1){6}}
  \put(70,11){\line(0,1){6}}
  \put(55,13){\code CACHE}
  
  \put(75,11){\line(1,0){20}}
  \put(75,17){\line(1,0){20}}
  \put(75,11){\line(0,1){6}}
  \put(95,11){\line(0,1){6}}
  \put(82,13){\code MEM}
  
  \put(50,0){\line(1,0){20}}
  \put(50,6){\line(1,0){20}}
  \put(50,0){\line(0,1){6}}
  \put(70,0){\line(0,1){6}}
  \put(57,2){\code IOM}
  
  \put(10,17){\vector(0,1){5}}
  \put(20,14){\vector(1,0){5}}
  \put(45,14){\vector(1,0){5}}
  \put(70,14){\vector(1,0){5}}
  \put(60,11){\vector(0,-1){5}}
\end{picture}
\caption{Internal modules of the KV10}
\end{figure}

\subsubsection{Arithmetic Processor -- APR}

The APR is the core of the processor, responsible for executing the instructions
and maintaining the processor state.

\subsubsection{Pager -- PAG}

The pager is modeled after the paging box that MIT designed and built to support ITS.  It
maps the 18-bit virtual addresses generated by the APR into 22-bit physical addresses and
generates page faults on protection violations or missing memory pages.

\subsubsection{Cache}

The cache is a two-way, set associative, write-through cache.  It also handles converting
between the 36-bit words of the PDP-10 and the width of the memory which is likely not
36-bits.

Additionally, the cache is where the I/O bus is split out from the memory bus.  Since the
pager and cache have their own I/O devices, they grab their own device operations as they
go by.  Any that make it past the cache are directed to the IOM.  When, in the future, we
add DMA devices, they can communicate with the cache to either bypass it, to update it, or
to invalidate entries as appropriate.

\subsubsection{Memory Controller -- MEM}

The memory controller varies, depending on the memory technology in use such as SRAM,
SDRAM, or MRAM.  Because of variables like the memory width, mapping of that width into
the cache's linelength, and optimizations like burst-mode, the memory controller and the
cache are closely tied.

\subsubsection{I/O Multiplexer -- IOM}

The I/O Multiplexer includes connections to all the rest of the I/O devices in the system.
Simple devices may be implemented inside the IOM while more complex ones will get their
own modules.

\subsubsection{Console}

The operator's console or front-panel was a staple of computers from the 1950s and 1960s.
Using the console, an operator could control the computer, enter simple programs, or boot
the machine.  Front-panels have become pass\'{e}, with good reason, but one is available
for the KV10.\footnote{The console should be optional but I'll have to figure out how to
  boot the machine without one.}

\section{On Names}

\subsection{Processor}

This implementation of the PDP-10 architecture is called the KV10. As mentioned above, it
was designed explicitly to run the ITS operating system, namely with a KA-like interrupt
system and the MIT Paging Box (also \code{CIRC} and one-proceed (yet to be
implemented)). However, being implemented in Verilog, it will be fairly
straightforward to have variations such as extra instructions, different paging hardware,
and extended memory so it can run TOPS-20.

The exact combination of compile options as well as the version of the code used are 
identified by option codes following the name.

\begin{center} \large KV10A-FDICp-10-1.3 \end{center}

\begin{description}
  \item[model] \hfill
    \begin{description}
      \item[A] The base model.  Essentially this implements the KA10 instruction set and
        interrupt architecture, a single set of accumulators, and so on.  Really it's
        taken more from the PDP-10/X.
      \item[L] The extended instructions of the KL10 processor, its interrupt
        architecture, and multiple accumulator sets.  There are probably other differences
        but I haven't studied the KL10 very much.  Anyway, if someone puts the work in to
        let the KV10 run TOPS-20, it will get a model designation.
    \end{description}
  \item[options] Options are listed in this order.
    \begin{description}
      \item[F] Implemented on an FPGA.
      \item[V] Implemented on an ASIC.
      \item[P] Implemented as a printed IC.
      \item[D] SDRAM controller.
      \item[1] DDR SDRAM controller.
      \item[2] DDR2 SDRAM controller.
      \item[3] DDR3 SDRAM controller.
      \item[4] DDR4 SDRAM controller.
      \item[I] The ITS pager as described for the PDP-10/X.
      \item[C] Implements the \code{CIRC} instruction.
      \item[p] Implements One-Proceed.
      \item[U] Unassigned Codes indirect through 60/61 instead of 40/41.
      \item[X] Implements extended addressing.
    \end{description}
  \item[cache] \hfill \\ The size of the cache is indicated by $log_2$ of the number of
    words in the cache.  For instance, 10 indicates a 1,024 word cache.  0 indicates no
    cache rather than one word.
  \item[version] \hfill \\
    The version number of the code as major.minor.
\end{description}

\subsection{I/O Devices}

I/O devices get their own names separately from the processor [to be described later].
Since many of the I/O devices are actually implemented along with the processor, it might
make sense to have a list like the option list along with the processor name.  I haven't
decided yet.

\subsection{Computer}

Computers include a realization of the processor, some memory, plus a set of supported
I/O devices and are named separately from all of those.  The initial realization, only run
a few times, was on a Terasic DE2-115 FPGA board and called Trilobyte.  The current
intention is to design and build a daughter card to go with the ZTEX 2.13 FPGA module
providing a useful set of I/O ports.  This will be called Amonite.


\chapter{APR}

\section{Instructions}

\subsubsection{CIRC - Circulate}

\begin{register36}
  \bits{0}{8}{\small 247}
  \bits{9}{12}{\small A}
  \bit{13}{\small I}
  \bits{14}{17}{\small X}
  \bits{18}{35}{\small Y}
\end{register36}

\code{CIRC} was added to the MIT KA10s in place of what was usually an unassigned code.
This instruction rotates the two accumulators \code{A} and \code{A+1} the number of
positions specified by \code{E}\marginpar{\raggedright \tiny The DEC documentation
  specifies that E is taken modulo 256; it never has a magnitude greater than 255. The
  diagnostics make it clear that -256 is expected to move 256 positions.} very much like
\code{ROTC} except it rotates \code{A+1} in the opposite direction. If \code{E} is
positive, bit 0 of \code{A} is rotated into bit 0 of \code{A+1} and bit 35 of \code{A+1}
is rotated into bit 35 of \code{A}.  If \code{E} is negative, bit 35 of \code{A} is
rotated into bit 35 of \code{A+1} and bit 0 of \code{A+1} is rotated into bit 0 of
\code{A}.\marginpar{\raggedright \tiny \code{CIRC A,36} will swap \code{A} and \code{A+1}
  while reversing their bit order.}

\setlength{\unitlength}{.01\textwidth}
\begin{picture}(95,15)
  \thicklines
  \put(10,0){\line(1,0){30}}
  \put(10,6){\line(1,0){30}}
  \put(10,0){\line(0,1){6}}
  \put(40,0){\line(0,1){6}}
  \put(24,2){\code{A}} \put(11,7){\tiny 0} \put(38,7){\tiny 35}

  \put(58,0){\line(1,0){30}}
  \put(58,6){\line(1,0){30}}
  \put(58,0){\line(0,1){6}}
  \put(88,0){\line(0,1){6}}
  \put(70,2){\code{A+1}} \put(59,7){\tiny 0} \put(86,7){\tiny 35}
	
  \put(10,3){\line(-1,0){6}}
  \put(4,3){\line(0,1){8}}
  \put(4,11){\line(1,0){40}}
  \put(44,11){\line(1,-1){8}}
  \put(52,3){\vector(1,0){6}}
	
  \put(88,3){\line(1,0){6}}
  \put(94,3){\line(0,1){8}}
  \put(94,11){\line(-1,0){40}}
  \put(54,11){\line(-1,-1){8}}
  \put(46,3){\vector(-1,0){6}}
\end{picture}

\smallskip
Inclusion of the \code{CIRC} instruction is controlled by the \texttt{CIRC} option in the
\texttt{constants.vh}.

\section{Interrupts and UUOs}

\subsection{Interrupt Instructions}

On the KV10, any instruction may be used as an interrupt instruction though that doesn't mean
any instruction makes sense there and most haven't been tested.  There are three broad
classes of instruction that have different effects when used as an interrupt instruction.

\begin{description}
  \item[jumps] Instructions which cause a jump will clear the CM flag (put the processor
    in exec mode) and jump to the destination address as per the instruction.  \code{JSR}
    is the typical example of this and the most commonly used interrupt instruction.  The
    interrupt service routine is expected to clear the condition causing the interrupt (if
    needed) and dismiss the interrupt with \code{JEN}.
  \item[skips] For instructions that may skip, if they do not skip then they execute the
    instruction at 41+2*N (where N is the PI channel number) as an interrupt instruction.
    If \emph{that} instruction may skip, the action of the APR is undefined.  If the
    instruction does skip, then the interrupt is dismissed and the interrupted program
    continues.

    This is here for the \code{BLKO} and \code{BLKI} instructions.  Since implementing
    this requires specific code to be added for each instruction that skips, I may or may
    not add the capability to other instructions.
  \item[everything else] Instructions that normally proceed to the next instruction take
    their action then dismiss the interrupt and return to the interrupted program.
\end{description}

\subsection{Unassigned Codes}

\marginpar{\raggedright \tiny The unassigned codes are 100-107, 114-117, 123, and (if
  \code{CIRC} is not included) 247.}The KA10 handles unassigned codes much like MUUOs
except they go through locations 60 and 61 rather than 40 and 41.  The KX10 sends both
MUUOs and unassigned codes through locations 40 and 41.  The KV10 may do it either way and
is controlled through the \texttt{UAC} option in \texttt{constants.vh}.  Defining
\texttt{UAC} causes the KV10 to use locations 60 and 61 for unassigned code processing.
\footnote{At some point I expect I will settle on one or the other and remove this compile
  option.}

\subsection{Errors}

The KX10 defines hard errors as coming from I/O operations non-existent devices.  The KV10
may also generate hard errors on accessing non-existent memory if the MEM module is
capable of detecting and signaling this condition.

\chapter{Input / Output}

\section{BLKI}

On some devices, \code{BLKI} works a little differently than on most PDP-10s.  Normally
\code{BLKI} skips if the count in the left half of location \code{E} is not zero so
not-skipping indicates the read buffer is full and reading is finished.  However, in some
cases the I/O device may know better than the software when the end is reached.  These
devices may notify the APR they've reached the end and this will cause \code{BLKI} to not
skip even though the count has not reached 0.

An example of this might be an Ethernet device.  It can start delivering data to the
processor before it knows the length of the packet so a device driver that wanted to use
\code{BLKI} would not know how many words to set up in its block.  With this modification,
when either the end of the packet or the end of the buffer is reached, \code{BLKI} doesn't
skip.  The code outside of the \code{BLKI} loop then needs to check why it was reached, if
it was end of packet or buffer overflow.

\section{I/O Devices}

Some I/O devices go with the processor itself (APR, PI, and PAG) while others are specific
to the particular realization of the computer.  It may be eventually that this distinction
will be important and the implementation specific devices will be separated out into
separate manuals.  That's awfully forward looking; my optimism knows no bounds.

The operations of \code{CONSZ}, \code{CONSO}, \code{BLKO}, and \code{BLKI} are not
described in here as they're just operations on top of the base of \code{CONI},
\code{DATAO}, and \code{DATAI}.  Any exceptions will be noted -- so far, there are none.


\subsection{APR -- Device 000}

\subsubsection{CONI APR, E}

\begin{register36}
  \bit{0}{E\\H\\E}
  \bit{1}{E\\S\\E}
  \bit{2}{E\\E\\2}
  \bit{3}{E\\E\\1}
  \bit{4}{E\\U\\2}
  \bit{5}{E\\U\\1}
  \bits{6}{8}{E\\I\\A}
  \bit{9}{T\\H\\E}
  \bit{10}{T\\S\\E}
  \bit{11}{T\\E\\2}
  \bit{12}{T\\E\\1}
  \bit{13}{T\\U\\2}
  \bit{14}{T\\U\\1}
  \bits{15}{17}{T\\I\\A}
  \bit{25}{F\\H\\E}
  \bit{26}{F\\S\\E}
  \bit{27}{F\\E\\2}
  \bit{28}{F\\E\\1}
  \bit{29}{F\\U\\2}
  \bit{30}{F\\U\\1}
  \bit{31}{E\\I\\R}
  \bit{32}{T\\I\\R}
\end{register36}

\subsubsection{CONO APR, E}

\begin{register36}
  \bit{18}{S\\S\\E}
  \bit{19}{R\\I\\O}
  \bit{20}{C\\S\\F}
  \bit{21}{S\\F}
  \bit{22}{C\\F}
  \bit{23}{L\\E}
  \bit{24}{L\\T}
  \bit{25}{M\\H\\E}
  \bit{26}{M\\S\\E}
  \bit{27}{M\\E\\2}
  \bit{28}{M\\E\\1}
  \bit{29}{M\\U\\2}
  \bit{30}{M\\U\\1}
  \bits{33}{35}{I\\A}
\end{register36} 

\subsubsection{DATAI APR, E}
\subsubsection{DATAO APR, E}

\begin{register36}
  \bits{0}{35}{\small Switch Register}
\end{register36}

Since the switches in the BL10 console are capacitive touch switches whose current state
is held by internal flip-flops, like the KI10 their values can be written as well as read.
Unlike the KI10, writing is done to the APR device rather than paper-tape reader (PTR).
This switch register is reflected in and controlled by the \textsc{data switches} on the
console.

If the console is not included, the switch register is still there and can be read and
written under software control.  It's just that it can't be observed by looking at the
front of the computer and it can't be changed manually.

\subsection{PI -- Device 004}


\subsubsection{CONI PI, E}

\begin{register36}
  \bit{11}{S\\R\\1}
  \bit{12}{S\\R\\2}
  \bit{13}{S\\R\\3}
  \bit{14}{S\\R\\4}
  \bit{15}{S\\R\\5}
  \bit{16}{S\\R\\6}
  \bit{17}{S\\R\\7}
  \bit{21}{I\\P\\1}
  \bit{22}{I\\P\\2}
  \bit{23}{I\\P\\3}
  \bit{24}{I\\P\\4}
  \bit{25}{I\\P\\5}
  \bit{26}{I\\P\\6}
  \bit{27}{I\\P\\7}
  \bit{28}{G\\E}
  \bit{29}{L\\E\\1}
  \bit{30}{L\\E\\2}
  \bit{31}{L\\E\\3}
  \bit{32}{L\\E\\4}
  \bit{33}{L\\E\\5}
  \bit{34}{L\\E\\6}
  \bit{35}{L\\E\\7}
\end{register36}

\subsubsection{CONO PI, E}

\begin{register36}
  \bit{22}{C\\S\\R}
  \bit{23}{R\\P\\I}
  \bit{24}{S\\S\\R}
  \bit{25}{S\\L\\E}
  \bit{26}{C\\L\\E}
  \bit{27}{C\\G\\E}
  \bit{28}{S\\G\\E}
  \bit{29}{L\\1}
  \bit{30}{L\\2}
  \bit{31}{L\\3}
  \bit{32}{L\\4}
  \bit{33}{L\\5}
  \bit{34}{L\\6}
  \bit{35}{L\\7}
\end{register36}

\subsubsection{DATAO PI, E}

\begin{register36}
  \bits{0}{35}{\small Memory Indicator}
\end{register36}

Display the contents of location \code{E} on the console \textsc{memory/program data} and
light the \textsc{mem} light.

\subsubsection{DATAI PI, E}

This one is up for grabs.  I could just read back in the value written out to the Memory
Indicator but since those can't be changed manually, it seems rather pointless.  I could
read in the address switches but I'd be disappointed not to have a way to set them too.  I
could make use of \code{DATAO PTR} like the KI did for writing the address switches.  I
could read the \textsc{read in device} switches on the console.  This has the potential
use of letting boot code know where it booted from and those switches could pick up the
functionality of the \textsc{sense} switches that the BL10 console doesn't have.

\chapter{Console}

\section{Hardware}

The BL10 console device is an array of lights and capacitive touch switches designed to
display some of the internal state of a PDP-10 processor and let an operator control the
computer.  It communicates with the processor over an I2C bus so it doesn't come close to
keeping up at full speed.  Humans can't see lights blink that rapidly anyway.

It has an alternative communications port of a logic-level async serial interface with a
connector that matches with the FTDI serial to USB cables that are readily available.
This is to enable someone to implement console functions on a simulated processor such as
the KLH10 or SIMH.

\begin{figure}
\includegraphics[angle=0,keepaspectratio=true,width=\textwidth]{../front-panel/overlay.pdf}
\caption{BL10 Operator's Console}
\end{figure}

\section{Operation}

The console gives an operator direct, low-level control over the KV10.  It can be used to
poke around with the base machine, enter simple programs, or boot the computer.

Starting in the top, right: green lights indicate power is applied and the processor is
running.  Three red lights indicate the processor is stopped and the reason for stopping,
whether manual (from the console), the program (it executed a \code{HALT} instruction,
aka \code{JRST 4}), or the processor encountered a double hard error.

The PAG lights show if the pager is enabled and when it signals page fault and the
Processor Flags show those architectural flags that the programmer might use.

To the right of those are a block of lights showing the status of the PI system: whether
the system as a whole is enabled, which levels are enabled, which are in-progress, and
whether there are PI requests either from hardware devices or internally from the APR.

Moving down we have the Program Counter and below that the instruction that's executing.
To the right of the Program Counter are lights indicating if that instruction is being
executed in exec or user mode.

The Memory/Program Data lights serve a dual purpose.  When the APR is running, a
\code{DATAO PI} will write to these lights and be indicated by lighting the PROG light.
When the APR is halted, these lights will show the results of reading memory from the
console and this state will be indicated by the MEM light.

The Address Switches set the address to be read or written from the console.  Clear sets
the Address Switches to all 0 while Load sets them to the corresponding bits shown in the
Memory Data indicators.

To the left of the Address Switches are the Paging controls.  Reading and writing to
memory can be done to physical memory or to virtual memory of either the executive or
user memory spaces, as defined by the pager.  If virtual memory, only the right 18-bits of
the Address Switches are used.  The current pager only defined 22-bits of physical address
but there is potential room in the page-table entries for up to three more bits so I've
left room for that.

The Data Switches are used for writing data to memory locations.  The clear and load
switches to the right work like they work for the Address Switches.

The bottom row of switches are what initiate the various operations of the console.  [need
  to write a lot more here, once I know what operations I'm going to have.]

The Read In Device is for booting the computer.  Enter the device to boot from, then push
Read In to load the boot code from that device and run it.  Read In resets the device and
then reads, using repeated DATAI operations, a .SAV file from the device until it reaches
the end where it finds a \code{JRST} instruction and it starts the processor at the
location indicated.  The KV10 actually does execute this final instruction of the .SAV
file (in the sense of the \code{XCT} instruction) so if you arrange to put some other
instruction at the end of your .SAV file, you may get unexpected results.  Or perhaps
that's what you wanted to happen.


\begin{thebibliography}{9}

\bibitem{conroykx10}
  Dave Conroy,
  \emph{PDP-10/X System Manual}.
  \url{http://fpgaretrocomputing.org/pdp10x/}

\bibitem{PRM1970}
  Digital Equipment Corporation,
  \emph{PDP-10 System Reference Manual}.
  \url{http://bitsavers.com},
  1970.

\bibitem{PRM1971}
  Digital Equipment Corporation,
  \emph{DECsystem-10 System Reference Manual}.
  DEC-10-HGAD-D,
  1971.

\bibitem{PRM1982}
  Digital Equipment Corporation,
  \emph{DECsystem-10/DECSYSTEM-20 Processor Reference Manual}.
  AH-H391A-T1,
  June 1982.

\end{thebibliography}

\end{document}
